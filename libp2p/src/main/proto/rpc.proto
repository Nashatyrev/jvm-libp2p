syntax = "proto2";

package pubsub.pb;

message RPC {
	repeated SubOpts subscriptions = 1;
	repeated Message publish = 2;

	message SubOpts {
		optional bool subscribe = 1; // subscribe or unsubcribe
		optional string topicid = 2;
	}

	optional ControlMessage control = 3;
	repeated ErasureSample erasureSample = 4;
}

message Message {
	optional bytes from = 1;
	optional bytes data = 2;
	optional bytes seqno = 3;
	repeated string topicIDs = 4;
	optional bytes signature = 5;
	optional bytes key = 6;
}

message ErasureSample {
	required bytes messageID = 1;
	required int32 sampleIndex = 2;
	required bytes data = 3;
}

message ControlMessage {
	repeated ControlIHave ihave = 1;
	repeated ControlIWant iwant = 2;
	repeated ControlGraft graft = 3;
	repeated ControlPrune prune = 4;
	repeated ControlChoke choke = 5;
	repeated ControlUnChoke unchoke = 6;
	repeated ControlChokeMessage chokeMessage = 7;
	repeated ControlSending sending = 8;
	repeated ErasureHeader erasureHeader = 9;
	repeated ErasureAck erasureAck = 10;
}

message ControlIHave {
	optional string topicID = 1;
	repeated bytes messageIDs = 2;
}

message ControlIWant {
	repeated bytes messageIDs = 1;
}

message ControlGraft {
	optional string topicID = 1;
}

message ControlPrune {
	optional string topicID = 1;
	repeated PeerInfo peers = 2;
	optional uint64 backoff = 3;
}

message ControlChoke {
	optional string topicID = 1;
}

message ControlUnChoke {
	optional string topicID = 1;
}

message ControlChokeMessage {
	required bytes messageID = 1;
}

message ControlSending {
	required string topicID = 1;
	repeated bytes messageIDs = 2;
}

message ErasureHeader {
	required string topicID = 1;
	required bytes messageID = 2;
	required int32 totalSampleCount = 3;
	required int32 recoverSampleCount = 4;
	optional bytes data = 5;
}

message ErasureAck {
	required bytes messageID = 1;
	required int32 hasSamplesCount = 2;
	required int32 peerReceivedSamplesCount = 3;
}

message PeerInfo {
	optional bytes peerID = 1;
	optional bytes signedPeerRecord = 2;
}

message TopicDescriptor {
	optional string name = 1;
	optional AuthOpts auth = 2;
	optional EncOpts enc = 3;

	message AuthOpts {
		optional AuthMode mode = 1;
		repeated bytes keys = 2; // root keys to trust

		enum AuthMode {
			NONE = 0; // no authentication, anyone can publish
			KEY = 1; // only messages signed by keys in the topic descriptor are accepted
			WOT = 2; // web of trust, certificates can allow publisher set to grow
		}
	}

	message EncOpts {
		optional EncMode mode = 1;
		repeated bytes keyHashes = 2; // the hashes of the shared keys used (salted)

		enum EncMode {
			NONE = 0; // no encryption, anyone can read
			SHAREDKEY = 1; // messages are encrypted with shared key
			WOT = 2; // web of trust, certificates can allow publisher set to grow
		}
	}
}
